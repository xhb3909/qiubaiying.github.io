---
layout:     post
title:      栈的算法题
subtitle:   记一次猿辅导的面试题
date:       2018-06-30
author:     徐浩博
header-img: img/post-bg-mma-3.jpg
catalog: true
tags:
    - 数据结构和算法
	- 面试	
---

# 题目说明

一个栈里的元素是无序的如何让他变成有序的。可以开辟新的空间来完成该问题，不过只能最多开辟一个栈空间来实现。


# java实现代码(含注释)

```java

import java.util.Stack;


public class StackExample {


    public static Stack<Integer> sortStackElements(Stack<Integer> oldStack, Stack<Integer> newStack) {

        // 声明一个变量用于存放从原栈顶pop出的元素
        Integer oldTopElement;

        // 原栈长度是否为0
        while (oldStack.size() != 0) {

            // 新栈长度为0,默认直接把原栈元素直接pop出一个放到新栈中
            if (newStack.size() == 0) {
                newStack.push(oldStack.pop());
            }

            // 第二个pop出的元素
            oldTopElement = oldStack.pop();

            // 新栈长度是否为0
            while (newStack.size() != 0) {
                // 获取新栈的栈顶元素
                Integer newTopElement = newStack.peek();

                if (newTopElement.compareTo(oldTopElement) >= 0) {
                    // 新栈元素栈顶元素比原栈顶元素大,则直接把原栈元素入到新栈中
                    newStack.push(oldTopElement);
                    // 终止当前循环即可
                    break;
                } else {
                    // 否则就把新栈中的元素弹出,放到原栈的栈顶位置
                    oldStack.push(newStack.pop());
                    // 这个时候有一个隐含判断条件,需要时刻判断新栈中是否还有元素存在，若没有则直接把原栈中比较的元素放入新栈中
                    if (newStack.size() == 0) {
                        oldStack.push(oldTopElement);
                    }
                }
            }

        }

        return newStack;
    }

    public static void main(String[] args) {
        Stack<Integer> oldStack = new Stack<Integer>();
        Stack<Integer> newStack = new Stack<Integer>();
        oldStack.push(32);
        oldStack.push(11);
        oldStack.push(77);
        oldStack.push(88);
        oldStack.push(22);

        newStack = sortStackElements(oldStack, newStack);

        while (newStack.size() != 0) {
            System.out.println(newStack.pop());
        }

    }

```
