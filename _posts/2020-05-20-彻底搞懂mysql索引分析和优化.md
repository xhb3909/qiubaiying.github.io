---
layout:     post
title:      彻底搞懂mysql索引分析和优化
date:       2020-05-20
author:     xhb
header-img: img/home-bg.jpg
catalog: true
sid: 2020520
tags:
    - mysql
---

# 架构与索引
今天想和大家分享的话题是, mysql常见索引分析与优化。

### 架构介绍
mysql是一个关系型数据库，由瑞典MYSQL AB公司开发，目前属于Oracle公司。支持大型数据库，支持几千万条记录的数据仓库，32位系统表文件最大可支持4GB，
64位系统支持最大的表文件为8TB。

#### 配置文件
* 二进制bin-log: 主从复制和备份恢复
* 错误日志error-log: 默认关闭，记录严重的警告和错误信息
* 慢查询日志log: 默认关闭，记录查询的sql语句。开启会降低mysql整体性能.

* `myisam`存放方式

> frm文件(framework) (存放表结构)

> myd文件(data) (存放表数据)

> myi文件(index) (存放表索引)

* `innodb`存放方式

> `ibdata1` 如果没有开启innodb_file_per_table=on参数，则默认将所有表的数据都存在 `/usr/share/mysql/iddata1`目录下

> frm文件 存放表结构 (存放在库同名的包目录下)

> 单独存放 开启innodb_file_per_table参数配置，会单独以 table名.ibd 的文件名存储

#### 逻辑架构
![架构1](https://pic.kuaizhan.com/g3/15/8c/1df8-02ce-4728-a1b8-5e75871e04ca78)

![架构2](https://pic.kuaizhan.com/g3/48/4f/34f0-c43f-4a0c-b9d8-581381e4716d20)
mysql插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。

* 连接层

> 连接层是一些客户端和连接服务，本地客户端工具实现的类似TCP/IP的通信.完成一些连接处理、授权认证的安全方案。该层上引入了线程池的
概念，为通过认证安全接入的客户端提供线程。

* 服务层

> Management Services & Utilities: 系统管理和控制工具.

> SQL Interface: 接受用户输入的sql命令，返回用户需要查询的结果.

> Parser 解析器: sql命令传递到解析器的时候会被解析器验证和解析.

> Optimizer 查询优化器: sql语句在查询之前会使用查询优化器对查询进行优化.

> Cache和Buffer 查询缓存: 如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。

* 引擎层

> 存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同

* 存储层

> 数据存储层，主要是将数据存储在运行于某个设备的文件系统之上，并完成与存储引擎的交互。

----------------------

mysql查询流程

```
 
mysql的查询流程大致是：
mysql客户端通过协议与mysql服务器建连接，发送查询语句，先检查查询缓存，如果命中(一模一样的sql才能命中)，直接返回结果，否则进行语句解析。
在解析查询之前，服务器会先访问查询缓存(query cache)——它存储SELECT语句以及相应的查询结果集。如果某个查询结果已经位于缓存中，服务器就不会再对查询进行解析、优化、以及执行。
它仅仅将缓存中的结果返回给用户即可，这将大大提高系统的性能。
 
语法解析器和预处理：首先mysql通过关键字将SQL语句进行解析，并生成一颗对应的'解析树'。
mysql解析器将使用mysql语法规则验证和解析查询: 预处理器则根据一些mysql规则进一步检查解析树是否合法。
 
查询优化器当解析树被认为是合法的了，并且由优化器将其转化成执行计划。一条查询可以有很多种执行方式，最后都返回相同的结果。
优化器的作用就是找到这其中最好的执行计划。
 
然后，mysql默认使用的BTREE索引。 无论如何分析，至少在目前来说，mysql最多只用到表中的一个索引。

```
 
#### 存储引擎
mysql存储引擎有很多。但是比较重要的存储引擎就是InnoDB和MyISAM

* InnoDB引擎
> InnoDB是MySQL的默认事务型引擎，它被设计用来处理大量的短期(short-lived)事务。
除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。行级锁，适合高并发情况

* `MyISAM`存储引擎
> `MyISAM`提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但`MyISAM`不支持事务和行级锁(`myisam`改表时会将整个表全锁住)，崩溃后无法安全恢复。

* Archive引擎
> Archive存储引擎只支持INSERT和SELECT操作，在MySQL5.1之前不支持索引。
  Archive表适合日志和数据采集类应用。适合低访问量大数据等情况。Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。

* `Blackhole`引擎
> `Blackhole`引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。但服务器会记录`Blackhole`表的日志，所以可以用于复制数据到备库，
  或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。
  
* CSV引擎
> CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但不支持索引。
  CSV引擎可以作为一种数据交换的机制，非常有用。
  CSV存储的数据直接可以在操作系统里，用文本编辑器，或者excel读取。  
  
* Memory引擎
> 如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，
那么使用Memory表是非常有用。Memory表至少比MyISAM表要快一个数量级。(使用专业的内存数据库更快，如redis)

* Federated引擎
> Federated引擎是访问其他MySQL服务器的一个代理，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。

------------------


`Myisam` 和 `innoDB` PK

```
         MyISAM                                      I       InnoDB 

主外键    不支持                                               支持
事务      不支持                                               支持
行表锁    表锁，操作一条记录也会锁住整个表，不适合高并发的操作.       行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作
缓存      只缓存索引，不缓存真实数据                              不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响
表空间    小                                                   大   
关注点    性能                                                 事务
索引     B-tree                                               B+tree 
```

### 索引优化分析

有些时候对于我们开发人员来说对mysql进行优化，主要还是优化sql。sql慢就会导致执行时间和等待的时间过长。

导致sql慢可能有以下几个原因:
* 查询数据过多
* 关联了太多的表，太多join
* 没有利用到索引
* 服务器调优

#### 索引

* 是什么

> MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。
  可以得到索引的本质：索引是数据结构。

> 索引可类比字典，查mysql单词，需先定位到m，在m的基础上，在往后找。

> 排好序的快速查找数据结构。

![索引图1](https://pic.kuaizhan.com/g3/ef/fa/0004-5393-49c5-8631-bd0b3fb61a0539)

```
数据库系统维护着满足特定查找算法的数据结构。
左边是数据表，最左边的是记录的物理地址

加快col2查找，维护一个右边所示的二叉查找树，每个节点
分别包含索引键值和一个指向对应数据记录物理地址的指针。这样就可以
使用二叉查找快速检索出符合条件的记录。

B-Tree: 自动根据两边的情况自动条件，使两端无限趋近于平衡状态。使性能最稳定。
弊端: 插入/修改操作很多时，需要不断调整平衡，消耗性能。

```

> 一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上

##### 优势/劣势

* 优势

> 提高数据检索的效率，降低数据库的IO成本

> 索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗

* 劣势

> 索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的

> 索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。
  因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，
  都会调整因为更新所带来的键值变化后的索引信息
  

##### 索引结构

* BTree索引

![索引图2](https://pic.kuaizhan.com/g3/f8/00/d410-046c-41d1-86c4-d21b844ea88286)

```
深蓝色的块是一个磁盘块，每个磁盘块包含几个数据项(深蓝)和指针(黄色)

如磁盘块1包含数据项17和35，包含指针P1、P2、P3， 
P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3
表示大于35的磁盘块。


[查找过程]
如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，
在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短(相比磁盘的IO)可以忽略不计，
通过磁盘块1的P2指针的磁盘地址把磁 盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间， 
锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次 IO。
真实的情况是，3层的b+树可以表示上百万的数据，如果上百 万的数据查找只需要三次IO，性能提高将是巨大的，
如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的 IO，显然成本非常非常高。

```

* B+Tree索引

![索引图3](https://pic.kuaizhan.com/g3/77/31/5807-ac97-42b7-8831-6cf30dfd11cd31)

```
B+TREE 第二级的 数据并不能直接取出来，只作索引使用。在内存有限 的情况下，查询效率高于 B-TREE
B-TREE 第二级可以直接取出来，树形结构比较重，在内存无限大的时候 有优势。

```

* BTree VS B+Tree

```
B树的关键字和记录是放在一起的，叶子节点可以看作外部节点， 
不包含任何信息; B+树叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。

在B树中，越靠近根节点的记录查找时间越快，只要找到关键字即 可确定记录的存在;
而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。
从这个⻆度看B树的性能好像要比B+树好，而在实际应用中却是B+树的性能要好些。
因为B+树的非叶子节点不存放实际的数据，这样每个节点可容纳的元素个数比B树多，树高比B树小，这样带来的好处是减少磁盘访问次数。
尽管B+树找到一个记录所需的比较次数要比B树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，
因此实际中B+树的性能 可能还会好些，而且B+树的叶子节点使用指针连接在一起，
方便顺序遍历这也是很多数据库和文件系统使用B+树的缘故。
```

* 聚簇索引

![聚簇索引](https://pic.kuaizhan.com/g3/b5/d8/ecd2-8e25-4496-9749-ca8b7382e8ac39)

```
聚簇 表示数据行和相邻的键值紧密的存储在一起。

按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大 量的io操作。

对于mysql数据库目前只有innodb数据引擎支持聚簇索引，而 Myisam并不支持聚簇索引。
由于数据物理存储排序方式只能有一种 ，所以每个Mysql的表 只能有一个聚簇索引。一般情况下就是该表的主键 。
为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列 尽量选用有序的顺序id，而不建议用无序的id，比如uuid这种。

```

##### 索引分类

* 主键索引
* 单值索引
* 唯一索引
* 复合索引

---------------------

* 哪些情况适合创建索引

> 频繁作为查询条件的字段可以创建索引(where后面的语句)

> 查询中与其他表关联的字段，外键关系建立索引.
  A表关联B表:A left join B 。 
  on后面的连接条件是A表查询B表的条件。所以B表被关联的字段建立索引能大大提高查询效率

> 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度.(group by or order by)

* 哪些情况不需要创建索引

> 表记录太少.

> 频繁增删改的表. 更新表时，MySQL不仅要保存数据，还要保存一下索引文件.

> 数据重复且分布平均的表字段. 索引的选择性是指索引列中不同数的比，比值越接近1，索引的选择性越好.


##### 常见瓶颈

* CPU

> 对大量数据进行比较、关联、排序、分组

* IO

> 内存满足不了缓存数据或排序等需要，导致产生大量物理IO。
> 查询执行效率低，扫描过多数据行。

* 锁

> 阻塞、死锁导致资源卡主

##### explain

explain为sql调优的问题，开了一盏黑夜中的明灯，让人看到了光明。

* 是什么

> EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是
  如何处理你的SQL语句的

###### 实战

![explain](https://pic.kuaizhan.com/g3/ff/14/6efc-1b53-4b81-b900-56dbe68d0b7b54)

* id

> select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序

> id相同，执行顺序由上至下

![explain-8](https://pic.kuaizhan.com/g3/ab/0a/b562-a17c-46f1-b411-2848c3521b7e91)

> id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行。

![explain-9](https://pic.kuaizhan.com/g3/be/e0/8000-6844-4cab-85d2-29e6aa75be4038)


* select_type

> simple: 简单的 select 查询,查询中不包含子查询或者UNION

> primary: 查询中若包含任何复杂的子部分，最外层查询则被标记为Primary

> derived: 在FROM列表中包含的子查询被标记为DERIVED(衍生)
            MySQL会递归执行这些子查询, 把结果放在临时表里。

> `subquery`: 在SELECT或WHERE列表中包含了子查询

> union: 若第二个SELECT出现在UNION之后，则被标记为UNION；

![explain-union](https://pic.kuaizhan.com/g3/4d/3f/3ca7-682e-4bc1-b4fa-6cae3b5a734275)


* table

> 显示这一行的数据是关于哪张表的

* type

访问类型，显示查询使用了何种类型，从好到查排序 system > const > eq_ref > ref > range > ALL

> system: 表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，可以忽略不计

> const: 表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快
               如将主键置于where列表中，MySQL就能将该查询转换为一个常量

![const](https://pic.kuaizhan.com/g3/aa/40/e563-0c25-4c92-ae27-08039bd9a56b73)

> eq_ref: 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描

![const](https://pic.kuaizhan.com/g3/74/06/c5ab-17ad-4a34-b310-b797d17d358177)

> ref: 非唯一性索引扫描，返回匹配某个单独值的所有行.
       本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，
       它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体

![ref_before](https://pic.kuaizhan.com/g3/1b/40/5e09-1481-4cf3-8301-1079a4eac24791)

![ref_after](https://pic.kuaizhan.com/g3/39/4f/f3ff-1f6c-4064-9c4b-041846169cdf80)

> range: 只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引
         一般就是在你的where语句中出现了between、<、>、in等的查询
         这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。

![range](https://pic.kuaizhan.com/g3/fb/23/af44-3c6e-428f-bec4-05b48d586a0e59)

> index: Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。
         （也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）

![index](https://pic.kuaizhan.com/g3/b6/ad/62dc-6076-409f-afd2-a120bc243d4429)

> all: Full Table Scan，将遍历全表以找到匹配的行

* possible_keys

> 显示可能应用在这张表中的索引，一个或多个。
  查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用
  
* key

> 实际使用的索引。如果为null，则没有使用索引

* key_len

> 表示索引中使用的字节数，可通过该列计算查询使用的索引的长度
> key_len可以帮你检查是否充分的利用上了索引

* ref

> 显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值

![ref](https://pic.kuaizhan.com/g3/14/ce/f42a-cb64-4df7-b1a2-7c43c6e6f69f68)

* rows

> rows列显示MySQL认为它执行查询时必须检查的行数。(越少越好)

* extra (额外信息)

> `using filesort`: mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。
                    MySQL中无法利用索引完成的排序操作称为“文件排序”
                    
![using_file_sort_before](https://pic.kuaizhan.com/g3/59/77/0476-4009-4cb9-8737-34221cf8ba6f76)

![using_file_sort_after](https://pic.kuaizhan.com/g3/b3/83/5e3a-46f9-453b-88fe-1af346507f7b74)

> `Using temporary`: 使用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。

![using_temporary_before](https://pic.kuaizhan.com/g3/f1/b1/1e17-1e8f-4abd-b797-53437310536908)

![using_temporary_after](https://pic.kuaizhan.com/g3/2d/ff/96ba-0361-4de4-b388-5697d1aea0e603)

> `USING index`: 表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错
                 如果同时出现using where，表明索引被用来执行索引键值的查找;
                 如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。

![using_index](https://pic.kuaizhan.com/g3/0d/ec/63df-4a1c-459b-9606-a195a6b3cef607)

![using_where](https://pic.kuaizhan.com/g3/cb/10/0139-e699-4f32-bbdd-85475de2087138)

> Using where: 表示使用了where过滤

> using join buffer: 使用了连接缓存


##### 查询优化

* 索引最佳实践

```sql

CREATE TABLE staffs ( 
id INT PRIMARY KEY AUTO_INCREMENT, 
NAME VARCHAR (24) NULL DEFAULT '' COMMENT '姓 名', 
age INT NOT NULL DEFAULT 0 COMMENT '年龄',
pos VARCHAR (20) NOT NULL DEFAULT '' COMMENT '职位',
add_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '入职时间' ) CHARSET utf8 COMMENT '员工记录表' ; 

```

索引 idx_staffs_nameAgePos 建立索引时 以 name、age、pos 的顺序建立的

> 全值匹配

![all](https://pic.kuaizhan.com/g3/dc/6e/ee2e-7c36-4f47-9890-e76f44758fc603)

> 最佳左前缀法则: 如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。

![left](https://pic.kuaizhan.com/g3/99/6e/0473-455a-4dc6-99b9-5c78b7a13be944)

> 不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描

![func](https://pic.kuaizhan.com/g3/d3/13/ef94-065c-4aad-a9e5-bef33c48ed3081)

> 存储引擎不能使用索引中范围条件右边的列

![engine](https://pic.kuaizhan.com/g3/97/29/a17f-584d-43d3-b5e1-b1f19352458738)

> 尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select *

> mysql 在使用不等于!=的时候无法使用索引会导致全表扫描

> is not null 也无法使用索引,但是is null是可以使用索引的

![null](https://pic.kuaizhan.com/g3/5b/6a/9704-eabf-4c6e-8e3f-d0edd26e603b72)

> like以通配符开头('%abc...')mysql索引失效会变成全表扫描的操作 (思考: 解决like '%字符串%'时索引不被使用的方法)

![like](https://pic.kuaizhan.com/g3/80/5f/4a6b-035b-4097-a3b8-4c8314fac4e141)

> 字符串不加单引号索引失效

![单引号](https://pic.kuaizhan.com/g3/29/8e/b772-ce56-46ed-ae58-e7c4b403a3db99)

> 少用or,用它来连接时会索引失效

![or](https://pic.kuaizhan.com/g3/06/49/342f-48d1-4557-b782-d8362cf5bbf167)

> left join时，选择小表作为驱动表，大表作为被驱动表

> ORDER BY子句，尽量使用Index方式排序,避免使用FileSort方式排序

![order_by](https://pic.kuaizhan.com/g3/bf/32/de87-6e0f-4bd9-9f49-7c668ee9326f31)

> group by关键字: group by实质是先排序后进行分组，遵照索引建的最佳左前缀


### 尾声
今天的分享到这里就结束了，下次着手分享mysql事务和锁相关的话题。
